/*  co-gcc.lnt: This is the seed file for configuring Lint for use with
    GCC versions 2.95.3 and later.

    Like all compiler options files this file is intended to be used
    as follows:

         lint co-gcc.lnt source-files-to-be-linted

    Some of the information that co-gcc.lnt requires needs to be
    furnished with the help of the gcc system itself.

    If any of these directions are unclear, you may gain a better insight
    into what is happening by checking the file gcc-readme.txt

    For C, first create an empty file named empty.c and then
    run the command (options are case sensitive):

         gcc -E -dM empty.c >lint_cmac.h

    This will capture macro definitions in a file that will be included
    automatically at the beginning of each module by use of the -header
    option within co-gcc.lnt.  The macros may change as you change
    compiler options so that ultimately you may want to incorporate
    this step into a make facility.

    Next we need to determine the search directories.  If you run

         gcc -c -v empty.c

    you will see among other things this coveted list.  For example you
    might get:

         ...
         #include "..." search starts here
         #include <...> search starts here
         /usr/local/include
         /usr/lib/gcc/i686-apple-darwin8/4.0.1/include
         /usr/include
         /System/Library/Frameworks
         /Library/Frameworks
         End of search list.
         ...

    For each directory shown (there are five in the list above) prefix
    the directory name by a "--i" and place it in a file whose name is,
    say, include.lnt.  You may then begin linting programs by using the
    command

         lint co-gcc.lnt include.lnt  source-files

    Note: it is conventional to place both .lnt files into a single .lnt
    file called std.lnt

    For C++, run the command (options are again case sensitive):

         g++ -E -dM empty.c >lint_cppmac.h

    This will capture C++ macro definitions in a file that will be
    included automatically at the beginning of each C++ module
    at the request of co-gcc.lnt.

    Next we need to determine C++ search directories.  If you run

         g++ -c -v empty.c

    As in the case of C you should prepend a --i onto each directory
    displayed and place these options into a file such as include.lnt.
    Again, there is nothing sacred about the name and if you intend to
    do mixed C and C++ programming it will be necessary for you to use
    a differently named file.  The rest proceeds as before.

    Note, some options in this file (such as the size options, i.e. -sp4
    indicating that pointers are four bytes wide) may need to be changed.
    See "System Dependent Options" below.
*/

-cgnu             // Notifies FlexeLint that gcc is being used.

// Begin: System Dependent Options
// -------------------------------
-a#machine(i386)  // #assert's machine(i386)  (SVR4 facility).
+fdi              // Use the directory of the including file
-si4
-sp4
// -----------------------------
// End: System Dependent Options

+cpp(.cc)      // extensions for C++ that are commonly used in addition
                  // to the default extensions of .cpp and .cxx
-header(co-gcc.h) // Includes header generated by GCC.
+libh(co-gcc.h)   // Marks that header as library code.

// =========================================================
// +rw and -d options to cope with GNU syntax:
+ppw(ident)                 // Tolerate #ident
+ppw(warning)

// GCC provides alternative spellings of certain keywords:
-rw_asgn(__inline,inline)
-rw_asgn(__inline__,inline)
-rw_asgn(__signed__,signed)
-rw_asgn( __volatile__, volatile )
-rw_asgn( __volatile, volatile )
++d__const=const        // gconv.h uses __const rather than const
++dconst=const          // ensure const expands to const.

-rw_asgn( asm,      _up_to_brackets )
-rw_asgn( __asm,    _up_to_brackets )
-rw_asgn( __asm__,  _up_to_brackets )
// This re-definition of the various spellings of the asm keyword enables
// Lint to pass gracefully over expression-statements like:
// __asm __volatile ("fsqrt" : "=t" (__result) : "0" (__x));

++d__attribute__()=   // ignore this keyword and following parenthetical
++d__attribute()=     // variant spelling of "__attribute__"

// "__extension__" is GCC's way of allowing the use of non-standard
// constructs in a strict Standard-conforming mode.  We don't currently
// have explicit support for it, but we can use local suppressions.  For
// example, we can use -e(160) so that we will not see any Errors about
// GNU statement-expressions wrapped in __extension__().
++d"__extension__=/*lint -e(160) */"

++d__builtin_va_list=void*            // used by stdarg.h
++d__builtin_stdarg_start()=_to_semi  // ditto
++d__builtin_va_end()=_to_semi        // ditto
++d"__builtin_va_arg(a,b)=(*( (b *) ( ((a) += sizeof(b)) - sizeof(b) )))"
++d__null=0
+rw(_to_semi)           // needed for the two macros above.
+rw(__typeof__)         // activate __typeof__ keyword
-d__typeof=__typeof__   // an alternative to using __typeof__

+rw( __restrict )
+rw( __restrict__ )
-rw(__except)           // This MS reserved word is used as an identifier
+rw( __complex__, __real__, __imag__ )  // reserved words that can be ignored.
++d__builtin_strchr=(char*)     // permits the inline definition ...
++d__builtin_strpbrk=(char*)    // of these functions to be linted ...
++d__builtin_strrchr=(char*)    // without drawing a complaint
++d__builtin_strstr=(char*)     // about the use of a non-standard name
++d__PRETTY_FUNCTION__=___function___ // lint defines ___function___ internally
++d__FUNCTION__=___function___        // lint defines ___function___ internally
++d__func__=___function___  // Some C++ modes support the implicit __func__
                            // identifier.


// =========================================================
// Other options supporting GNU C/C++ syntax:
+fld // enables the processing of _L_abel _D_esignators E.g.:
     // union { double d; int i; } u = { d: 3.141  };

// +fwc // wchar_t might be builtin; if so, uncomment
        // this option.

// =========================================================
// Generally useful suppressions:
-wlib(1)      // sets the warning level within library headers to 1
              // (no warnings, just syntax errors).  Comment out if you
              // are actually linting library headers.
-elib(123)    // 123 is really a warning, but it's in the "Error" range.
-elib(93)     // allow newlines within quoted string arguments to macros
-elibsym(628) // Suppress 628 for __builtin symbols.

-esym(528,__huge_val,__nan,__qnan,__qnanf,__snan,__snanf)
                       // We don't care if we don't reference some GNU functions
-esym(528,__gnu_malloc,__gnu_calloc)

//  The following functions exhibit variable return modes.
//  That is, they may equally-usefully be called for a value
//  as called just for their effects.  Accordingly we inhibit
//  Warning 534 for these functions.
//  Feel free to add to or subtract from this list.

-esym(534,close,creat,fclose,fprintf,fputc)
-esym(534,fputs,fscanf,fseek,fwrite,lseek,memcpy,memmove,memset)
-esym(534,printf,puts,scanf,sprintf,sscanf,strcat,strcpy)
-esym(534,strncat,strncpy,unlink,write)

// For non-ANSI compilers we suppress messages 515 and 516
// for functions known to have variable argument lists.
// For ANSI compilers, header files should take care of this.

-esym(515,fprintf,printf,sprintf,fscanf,scanf,sscanf)
-esym(516,fprintf,printf,sprintf,fscanf,scanf,sscanf)
-esym(1702,*operator<<,*operator>>)
-esym(534,*operator<<,*operator>>)
-esym(1055,*__builtin*)
-esym(718,*__builtin*)   // The compiler does not need these ...
-esym(746,*__builtin*)   // declared and it knows their prototypes.


