#include "scr_es35sw_th_sensor.h"

#define X_ICON_ES35_CURSOR				(40)
#define Y_ICON_ES35_CURSOR				(10)
#define X_TEMP_CURSOR					(90)
#define Y_TEMP_CURSOR					(20)
#define Y_TEMP_CURSOR_NEXT_LINE			(16)

#define ES35_TEMP_REG					0
#define ES35_HUM_REG					1

static const unsigned char PROGMEM icon_temp_12x13[] = {
	0x00, 0x00, 0x18, 0x00, 0x3c, 0x00, 0x34, 0x00, 0x34, 0x00, 0x34, 0x00,
	0x34, 0x02, 0x66, 0x03, 0x42, 0x02, 0x66, 0x02, 0x3c, 0x02, 0x00, 0x07,
	0x00, 0x00
};

static const unsigned char PROGMEM icon_hum_13x13[] = {
	0x00, 0x00, 0x08, 0x00, 0x1c, 0x00, 0x36, 0x00, 0x36, 0x00, 0x3e, 0x00, 0x1c, 0x80, 0x01, 0xc0,
	0x03, 0x60, 0x03, 0x60, 0x03, 0xe0, 0x01, 0xc0, 0x00, 0x00
};

static const unsigned char PROGMEM icon_es35_sensor_28x55[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0x58, 0x00, 0x00, 0x01, 0x58, 0x00,
	0x00, 0x01, 0x58, 0x00, 0x00, 0x01, 0x58, 0x00, 0x00, 0x01, 0x58, 0x00, 0x00, 0x01, 0x58, 0x00,
	0x00, 0x01, 0x58, 0x00, 0x00, 0x01, 0x58, 0x00, 0x00, 0x01, 0x58, 0x00, 0x00, 0x01, 0x78, 0x00,
	0x00, 0x01, 0x78, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x3f, 0xf8, 0x00,
	0x00, 0x61, 0xf8, 0x00, 0x00, 0x61, 0xf8, 0x00, 0x00, 0x61, 0xf8, 0x00, 0x00, 0x61, 0xf8, 0x00,
	0x00, 0x63, 0xf8, 0x00, 0x00, 0x63, 0xf8, 0x00, 0x00, 0x63, 0xf8, 0x00, 0x00, 0x7f, 0xf8, 0x00,
	0x00, 0x3f, 0xf8, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x01, 0xf8, 0x00,
	0x00, 0x01, 0xf8, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x01, 0xf8, 0x00,
	0x00, 0x01, 0x08, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x60, 0x00,
	0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x01, 0xc0, 0x60, 0x00, 0x03, 0xe0, 0xe0, 0x00,
	0x07, 0x7f, 0xc0, 0x00, 0x06, 0x3f, 0x80, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
	0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
	0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static void view_scr_es35sw_th_sensor();

view_dynamic_t dyn_view_item_es35sw_th_sensor = {
	{
		.item_type = ITEM_TYPE_DYNAMIC,
	},
	view_scr_es35sw_th_sensor
};

view_screen_t scr_es35sw_th_sensor = {
	&dyn_view_item_es35sw_th_sensor,
	ITEM_NULL,
	ITEM_NULL,

	.focus_item = 0,
};

void view_scr_es35sw_th_sensor() {
	char str[5];
	USHORT tempVal = (MB_ES35SW_TH_Sensor.listRegDevice[ES35_TEMP_REG].regValue * MB_ES35SW_TH_Sensor.listRegDevice[ES35_TEMP_REG].ratio);
	USHORT humVal  = (MB_ES35SW_TH_Sensor.listRegDevice[ES35_HUM_REG].regValue * MB_ES35SW_TH_Sensor.listRegDevice[ES35_HUM_REG].ratio);
	
	view_render.clear();
	view_render.drawRect(0, 0, 128, 64, WHITE);
	view_render.fillRoundRect(0, 0, 42, 14, 1, WHITE);

	/* Show es35 sensor icon*/
	view_render.setTextSize(1);
	view_render.setTextColor(BLACK);
	view_render.setCursor(8, 4);
	view_render.print("ES35");

	view_render.setTextColor(WHITE);
	view_render.drawBitmap (X_ICON_ES35_CURSOR,
							Y_ICON_ES35_CURSOR,
							icon_es35_sensor_28x55,
							28,
							55,
							WHITE);

	/* Show temperature icon*/
	view_render.drawBitmap (X_TEMP_CURSOR -15,
							Y_TEMP_CURSOR -6,
							icon_temp_12x13,
							12,
							13,
							WHITE);
	if (tempVal > 80) strcpy(str, "UKN");
	else xsprintf(str,"%02d%s", tempVal, (const int8_t*)MB_ES35SW_TH_Sensor.listRegDevice[ES35_TEMP_REG].unit);

	view_render.setCursor(X_TEMP_CURSOR, Y_TEMP_CURSOR);
	view_render.print(str);

	/* Show humidity icon*/
	view_render.drawBitmap (X_TEMP_CURSOR -15,
							Y_TEMP_CURSOR -6 + Y_TEMP_CURSOR_NEXT_LINE,
							icon_hum_13x13,
							13,
							13,
							WHITE);

	if (humVal > 100) strcpy(str, "UKN");
	else xsprintf(str,"%02d%s", humVal, (const int8_t*)MB_ES35SW_TH_Sensor.listRegDevice[ES35_HUM_REG].unit);

	view_render.setCursor(X_TEMP_CURSOR, Y_TEMP_CURSOR + Y_TEMP_CURSOR_NEXT_LINE);
	view_render.print(str);

	view_render.update();
}

void scr_es35sw_th_sensor_handle(ak_msg_t* msg) {
	switch (msg->sig) {
	case SCREEN_ENTRY: {
		APP_DBG_SIG("SCREEN_ENTRY\n");

		timer_set(AC_TASK_DISPLAY_ID, \
				  AC_DISPLAY_SHOW_MODBUS_PULL_UPDATE, \
				  AC_DISPLAY_SHOW_MODBUS_PULL_INTERVAL, \
				  TIMER_PERIODIC);

		timer_set(AC_TASK_DISPLAY_ID, \
				  AC_DISPLAY_SHOW_MODBUS_PULL_SLEEP, \
				  AC_DISPLAY_SHOW_MODBUS_PULL_SLEEP_INTERVAL, \
				  TIMER_ONE_SHOT);
	}
		break;

	case AC_DISPLAY_SHOW_MODBUS_PULL_UPDATE: {
		updateDataModbusDevice(&MB_ES35SW_TH_Sensor);
	}
		break;

	case AC_DISPLAY_SHOW_MODBUS_PULL_SLEEP: {
		APP_DBG_SIG("AC_DISPLAY_SHOW_MODBUS_PULL_SLEEP\n");
		SCREEN_TRAN(scr_idle_handle, &scr_idle);
	}
		break;

	case AC_DISPLAY_BUTON_MODE_RELEASED: {
		APP_DBG_SIG("AC_DISPLAY_BUTON_MODE_RELEASED\n");
		timer_remove_attr(AC_TASK_DISPLAY_ID, AC_DISPLAY_SHOW_MODBUS_PULL_UPDATE);
		SCREEN_TRAN(scr_idle_handle, &scr_idle);
	}
		break;

	case AC_DISPLAY_BUTON_UP_RELEASED: {
		APP_DBG_SIG("AC_DISPLAY_BUTON_UP_RELEASED\n");
		BUZZER_PlayTones(tones_3beep);
	}
		break;

	case AC_DISPLAY_BUTON_DOWN_RELEASED: {
		APP_DBG_SIG("AC_DISPLAY_BUTON_DOWN_RELEASED\n");
		timer_remove_attr(AC_TASK_DISPLAY_ID, AC_DISPLAY_SHOW_MODBUS_PULL_UPDATE);
		SCREEN_TRAN(scr_lhio404_io_device_handle, &scr_lhio404_io_device);
	}
		break;

	default:
		break;
	}
}
